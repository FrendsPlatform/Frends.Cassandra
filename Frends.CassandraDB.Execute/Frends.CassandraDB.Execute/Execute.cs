using Frends.CassandraDB.Execute.Definitions;
using System.ComponentModel;
using System;
using System.Threading;
using System.Collections.Generic;
using Cassandra;
using Cassandra.DataStax.Auth;
using Newtonsoft.Json.Linq;

namespace Frends.CassandraDB.Execute;

/// <summary>
/// CassandraDB Task.
/// </summary>
public class CassandraDB
{
    /// <summary>
    /// CassandraDB Execute operation.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.CassandraDB.Execute)
    /// </summary>
    /// <param name="input">Input parameters.</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this task.</param>
    /// <returns>Object { bool Success, JToken QueryResults, List&lt;string&gt; Warnings }</returns>
    public static Result Execute([PropertyTab] Input input, CancellationToken cancellationToken)
    {
        var queryResult = new Dictionary<int, List<QueryResult>>();
        var warnings = new List<string>();
        var cluster = GetCluster(input);

        try
        {
            var statement = string.IsNullOrWhiteSpace(input.AsUser)
                ? new SimpleStatement(input.Query)
                : new SimpleStatement(input.Query).ExecutingAs(input.AsUser);
            var rs = cluster.Execute(statement);
            var count = 0;

            foreach (var i in rs)
            {
                cancellationToken.ThrowIfCancellationRequested();
                var list = new List<QueryResult>();
                var rows = i;
                for (var j = 0; j < rs.Columns.Length; j++)
                    list.Add(new QueryResult() { Key = rs.Columns[j].Name, Value = rows[j] });

                queryResult.Add(count, list);
                count++;
            }

            if (rs.Info.Warnings != null)
            {
                foreach (var w in rs.Info.Warnings)
                    warnings.Add(w.ToString());
            }

            return new Result(
                rs.IsFullyFetched,
                JToken.FromObject(queryResult),
                warnings.Count > 0 ? warnings : null);
        }
        finally
        {
            cluster.ShutdownAsync().Wait(cancellationToken);
        }
    }

    private static ISession GetCluster(Input input)
    {
        var builder = Cluster
            .Builder()
            .AddContactPoints(GetContactPoints(input))
            .WithPort(input.Port);
        switch (input.AuthenticationMethods)
        {
            case AuthenticationMethods.None:
                // The builder is already configured enough
                break;

            case AuthenticationMethods.PlainTextAuthProvider:
                builder = builder.WithCredentials(input.Username, input.Password);
                break;

            case AuthenticationMethods.DsePlainTextAuthProvider:
                var dsePlainTextAuthProvider = string.IsNullOrWhiteSpace(input.AsUser)
                    ? new DsePlainTextAuthProvider(input.Username, input.Password)
                    : new DsePlainTextAuthProvider(input.Username, input.Password, input.AsUser);
                builder = builder.WithAuthProvider(dsePlainTextAuthProvider);
                break;

            default:
                throw new Exception("GetCluster error: Authentication method not supported.");
        }

        if (input.UseSsl)
        {
            var cert = input.CreateCertificate();
            var ssl = new SSLOptions().SetCertificateCollection(cert);
            builder = builder.WithSSL(ssl);
        }

        var cluster = builder.Build();

        var session = string.IsNullOrWhiteSpace(input.Keyspace)
                    ? cluster.Connect()
                    : cluster.Connect(input.Keyspace);

        return session;
    }

    private static string[] GetContactPoints(Input input)
    {
        var cps = new List<string>();

        foreach (var i in input.ContactPoints)
            cps.Add(i.Value);

        return cps.ToArray();
    }
}
